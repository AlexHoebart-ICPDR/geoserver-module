<?php

/**
 * @file
 * Main file of this module. Loads include files and implements general hooks.
 */

module_load_include('inc', 'geoserver', '/geoserver.openlayers');
module_load_include('inc', 'geoserver', '/geoserver.layer');

/**
 * Implements hook_cron().
 *
 * Access web interface of GeoServer every hour
 * with every active user to keep sessions alive.
 */
function geoserver_cron() {
  if (time() >= variable_get('geoserver_next_execution', 0)) {
    $users = db_query('SELECT uid FROM {sessions} WHERE uid != 0')->fetchAll(PDO::FETCH_COLUMN);
    foreach ($users as $uid) {
      geoserver_get('web/', $uid);
    }
    variable_set('geoserver_next_execution', time() + 3600);
  }
}

/**
 * Implements hook_ctools_plugin_api().
 *
 * Required for OpenLayers integration.
 */
function geoserver_ctools_plugin_api($module, $api) {
  if ($module == 'openlayers') {
    switch ($api) {
      case 'openlayers_layers':
        return array('version' => 1);
    }
  }
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function geoserver_ctools_plugin_directory($module, $plugin) {
  if ($module == 'openlayers' && $plugin == 'layer_types') {
    return 'plugins/openlayers/layer_types';
  }
  elseif ($module == 'geoserver' && $plugin == 'layer_types') {
    return 'plugins/geoserver/layer_types';
  }
}

/**
 * Implements hook_ctools_plugin_type().
 */
function geoserver_ctools_plugin_type() {
  return array('layer_types' => array());
}

/**
 * Implements hook_user_login().
 */
function geoserver_user_login(&$edit, $account) {

  $url = variable_get('geoserver_url', '');
  if (empty($url)) {
    // GeoServer not configured yet.
    return;
  }

  $url = parse_url($url);
  $url['host'] = empty($url['port']) ? $url['host'] : $url['host'] . ':' . $url['port'];
  $fields = 'username=' . urlencode($edit['values']['name']) .
            '&password=' . urlencode($edit['values']['pass']);

  $file   = geoserver_get_cookiefile();
  file_put_contents($file, '');

  $request = curl_init('http://' . $url['host'] . $url['path'] . 'j_spring_security_check');
  curl_setopt($request, CURLOPT_POST, 3);
  curl_setopt($request, CURLOPT_POSTFIELDS, $fields);
  curl_setopt($request, CURLOPT_COOKIEJAR, $file);
  curl_setopt($request, CURLOPT_RETURNTRANSFER, TRUE);
  curl_setopt($request, CURLOPT_HEADER, TRUE);
  $header = curl_exec($request);
  curl_close($request);

  preg_match('/Location:(.*?)\n/', $header, $matches);
  $location_url = parse_url(array_pop($matches));
  $location_path = isset($location_url['query']) ? $location_url['query'] : '';
  $cookies = geoserver_parse_cookiefile($file);

  if (isset($cookies['JSESSIONID']) && strpos($location_path, 'error=true') == FALSE) {
    setcookie('JSESSIONID', $cookies['JSESSIONID'], 0, $url['path'], $url['host']);
  }
  else {
    watchdog('geoserver', 'Could not authenticate %username at %url.',
        array('%username' => urlencode($edit['values']['name']), '%url' => $url), WATCHDOG_ERROR);
  }
}

/**
 * Implements hook_user_login().
 */
function geoserver_user_logout($account) {

  $url = parse_url(variable_get('geoserver_url', ''));
  $url['host'] = empty($url['port']) ? $url['host'] : $url['host'] . ':' . $url['port'];
  setcookie('JSESSIONID', '', 1, $url['path'], $url['host']);
  unlink(geoserver_get_cookiefile());
}

/**
 * Implements hook_node_insert().
 */
function geoserver_node_insert($node) {
  geoserver_truncate($node);
}

/**
 * Implements hook_node_update().
 */
function geoserver_node_update($node) {
  geoserver_truncate($node);
}

/**
 * Implements hook_node_delete().
 */
function geoserver_node_delete($node) {
  geoserver_truncate($node);
}

/**
 * Truncate GeoWebCache after changes to specific node.
 * Requires a cached WMS layer for the content type of the node.
 */
function geoserver_truncate($node) {

  $content_type_settings = variable_get('geoserver_content_type_settings', array());

  if (isset($content_type_settings[$node->type]) && $content_type_settings[$node->type]['gwc']) {
    // Node belongs to a content type with a GeoWebCache layer.
    $workspace = variable_get('geoserver_workspace', '');
    $settings = $content_type_settings[$node->type];
    $field_name = drupal_substr($settings['geometry_column'], 0, -9);
    $field = field_info_field($field_name);

    $geo_set = new PostgisGeometrySet($field['settings']['type'], $field['settings']['srid']);
    $geo_set->fromGeometry($node->{$field_name}[$node->language]);

    if (isset($node->original)) {
      foreach ($node->original->{$field_name}[$node->language] as $geometry) {
        $geo = new PostgisGeometry($field['settings']['type'], $field['settings']['srid']);
        $geo->fromGeometry($geometry);
        $geo_set->add($geo);
      }
    }

    $layer = $workspace . ':' . trim($settings['layer']);
    $srid = explode(':', $settings['gwc_srs']);
    $bbox = preg_split('/[\, ]/', drupal_substr($geo_set->getBox(0.1, $srid[1]), 4, -1));

    if (count($bbox) == 4) {

      $message = '<?xml version="1.0" encoding="UTF-8"?>
                  <seedRequest>
                    <name>' . $layer . '</name>
                    <bounds>
                      <coords>
                        <double>' . $bbox[0] . '</double>
                        <double>' . $bbox[1] . '</double>
                        <double>' . $bbox[2] . '</double>
                        <double>' . $bbox[3] . '</double>
                      </coords>
                    </bounds>
                    <gridSetId>' . $settings['gwc_srs'] . '</gridSetId>
                    <zoomStart>0</zoomStart>
                    <zoomStop>20</zoomStop>
                    <format>image/png</format>
                    <type>truncate</type>
                    <threadCount>1</threadCount>
                  </seedRequest>';

      geoserver_post('/gwc/rest/seed/' . $layer . '.xml', $message);
    }
  }
}

/**
 * Helper function to make a POST request.
 *
 * @param String $url Path relative to GeoServer URL.
 * @param String $content Payload.
 */
function geoserver_post($url, $content) {

  $url = variable_get('geoserver_url', '') . trim($url, '/');

  if (substr($url, -3) == 'xml') {
    $headers = array(
      'Content-Length: ' . drupal_strlen($content),
      'Content-type: text/xml',
    );
  }
  elseif (substr($url, -4) == 'json') {
    $content = json_encode($content);
    $headers = array(
      'Content-type: application/json'
    );
  }
  elseif (substr($url, -3) == 'sld') {
    $headers = array(
      'Content-type: application/vnd.ogc.sld+xml'
    );
  }
  else {
    throw new Exception('Unsupported format.');
  }

  $request = curl_init($url);

  curl_setopt($request, CURLOPT_POST, TRUE);
  curl_setopt($request, CURLOPT_POSTFIELDS, $content);
  curl_setopt($request, CURLOPT_HTTPHEADER, $headers);
  curl_setopt($request, CURLOPT_RETURNTRANSFER, TRUE);
  curl_setopt($request, CURLOPT_COOKIEFILE, geoserver_get_cookiefile());

  $result = new stdClass();
  $result->content = $content;
  $result->data = curl_exec($request);
  $result->code = curl_getinfo($request, CURLINFO_HTTP_CODE);
  curl_close($request);

  if ($result->code === 200) {
    watchdog('geoserver', 'Requested %url.', array('%url' => $url));
  }
  else {
    watchdog('geoserver', 'Requested %url with error %code: %message',
      array('%url' => $url, '%code' => $result->code, '%message' => $result->data), WATCHDOG_ERROR);
  }

  return $result;
}

/**
 * Helper function to make a PUT request.
 *
 * @param String $url Path relative to GeoServer URL.
 * @param String $content Payload.
 */
function geoserver_put($url, $content) {

  $url = variable_get('geoserver_url', '') . trim($url, '/');

  if (substr($url, -3) == 'xml') {
    $headers = array(
      'Content-Length: ' . drupal_strlen($content),
      'Content-type: text/xml',
    );
  }
  elseif (substr($url, -4) == 'json') {
    $content = json_encode($content);
    $headers = array(
      'Content-type: application/json'
    );
  }
  elseif (substr($url, -3) == 'sld') {
    $headers = array(
      'Content-type: application/vnd.ogc.sld+xml'
    );
  }
  else {
    throw new Exception('Unsupported format.');
  }

  // Create temporary file from payload.
  $file = tmpfile();
  fwrite($file, $content);
  fseek($file, 0);

  $request = curl_init($url);

  curl_setopt($request, CURLOPT_PUT, TRUE);
  curl_setopt($request, CURLOPT_INFILE, $file);
  curl_setopt($request, CURLOPT_INFILESIZE, drupal_strlen($content));
  curl_setopt($request, CURLOPT_HTTPHEADER, $headers);
  curl_setopt($request, CURLOPT_RETURNTRANSFER, TRUE);
  curl_setopt($request, CURLOPT_COOKIEFILE, geoserver_get_cookiefile());

  $result = new stdClass();
  $result->url  = $url;
  $result->data = curl_exec($request);
  $result->code = curl_getinfo($request, CURLINFO_HTTP_CODE);
  curl_close($request);

  if ($result->code === 200) {
    watchdog('geoserver', 'Requested %url.', array('%url' => $url));
  }
  else {
    watchdog('geoserver', 'Requested %url with error %code: %message',
      array('%url' => $url, '%code' => $result->code, '%message' => $result->data), WATCHDOG_ERROR);
  }

  return $result;
}

/**
 * Helper function to make a GET request.
 *
 * @param String $url Path relative to GeoServer URL.
 */
function geoserver_get($url, $uid = NULL) {

  $url = variable_get('geoserver_url', '') . trim($url, '/');

  $request = curl_init($url);

  curl_setopt($request, CURLOPT_RETURNTRANSFER, TRUE);
  curl_setopt($request, CURLOPT_COOKIEFILE, geoserver_get_cookiefile($uid));

  $result = new stdClass();
  $result->url = $url;
  $result->data = curl_exec($request);
  $result->code = curl_getinfo($request, CURLINFO_HTTP_CODE);
  curl_close($request);

  if (substr($result->url, -4) == 'json' && $result->code == 200) {
    $result->data = json_decode($result->data);
  }

  if ($result->code === 200) {
    watchdog('geoserver', 'Requested %url.', array('%url' => $url));
  }
  else {
    watchdog('geoserver', 'Requested %url with error %code: %message',
      array('%url' => $url, '%code' => $result->code, '%message' => $result->data), WATCHDOG_ERROR);
  }

  return $result;
}

/**
 * Helper function to make a DELETE request.
 *
 * @param String $url Path relative to GeoServer URL.
 */
function geoserver_delete($url) {

  $url = variable_get('geoserver_url', '') . trim($url, '/');

  $request = curl_init($url);

  curl_setopt($request, CURLOPT_RETURNTRANSFER, TRUE);
  curl_setopt($request, CURLOPT_COOKIEFILE, geoserver_get_cookiefile());
  curl_setopt($request, CURLOPT_CUSTOMREQUEST, 'DELETE');

  $result = new stdClass();
  $result->url = $url;
  $result->data = curl_exec($request);
  $result->code = curl_getinfo($request, CURLINFO_HTTP_CODE);
  curl_close($request);

  if (substr($result->url, -4) == 'json' && $result->code == 200) {
    $result->data = json_decode($result->data);
  }

  if ($result->code === 200) {
    watchdog('geoserver', 'Requested %url.', array('%url' => $url));
  }
  else {
    watchdog('geoserver', 'Requested %url with error %code: %message',
      array('%url' => $url, '%code' => $result->code, '%message' => $result->data), WATCHDOG_ERROR);
  }

  return $result;
}

/**
 * Get all layer types.
 *
 * @ingroup openlayers_api
 *
 * @param $reset
 *   Boolean whether to reset cache or not.
 * @return
 *   Array of layer type info.
 */
function geoserver_layer_types($reset = FALSE) {
  ctools_include('plugins');
  return ctools_get_plugins('geoserver', 'layer_types');
}

/**
 *  ...
 */
function geoserver_layers_load($reset = FALSE) {

  ctools_include('export');

  if ($reset) {
    ctools_export_load_object_reset('geoserver_layers');
  }

  $layers = ctools_export_load_object('geoserver_layers', 'all', array());
  $layer_types = geoserver_layer_types();

  foreach ($layers as $index => $layer) {
    $layer_object = geoserver_get_layer_object($layer);
    if ($layer_object) {
      $layers[$index] = $layer_object;
    }
    else {
      unset($layers[$index]);
    }
  }

  return $layers;
}

/**
 * Menu loader for layers. (%geoserver_layer)
 * @ingroup geoserver_api
 *
 * @param $name
 *   Layer name
 * @return array
 *   Layer export
 */
function geoserver_layer_load($name, $reset = FALSE) {

  ctools_include('export');

  if ($reset) {
    ctools_export_load_object_reset('geoserver_layers');
  }
  $layers = ctools_export_load_object('geoserver_layers', 'names', array($name));
  $layer_types = geoserver_layer_types();

  if (isset($layers[$name])) {
    return geoserver_get_layer_object($layers[$name]);
  }
  else {
    watchdog('geoserver', 'Layer %layer not found.', array('%layer' => $name), WATCHDOG_ERROR);
    return FALSE;
  }
}

/**
 * Get layer object
 *
 * @ingroup openlayers_api
 * @param $reset
 *   Boolean whether to reset cache or not
 * @return array
 *   array of layer info
 */
function geoserver_get_layer_object($layer) {
  // Static cache because this function will possibly be called in big loops.
  static $layer_types;
  if (!isset($layer_types)) {
    $layer_types = geoserver_layer_types();
  }

  $layer->title = t($layer->title);
  $layer->description = t($layer->description);

  if (is_array($layer->data) && isset($layer->data['type']) &&  isset($layer_types[$layer->data['type']])) {
    $layer_class = ctools_plugin_get_class($layer_types[$layer->data['type']], 'layer_type');
    if ($layer_class) {
      return new $layer_class($layer);
    }
  }
  watchdog('geoserver', 'Layer !layer_name is unavailable because its
    layer type or the module that provides its layer type is missing',
    array('!layer_name' => $layer->title),
    WATCHDOG_ERROR);
  return FALSE;
}

/**
 * Menu loader for layer types.
 *
 * @ingroup openlayers_api
 *
 * @param $name
 *   String identifier of layer type.
 * @param $reset
 *   Boolean whether to reset cache or not.
 * @return
 *   An instantiated layer type object or FALSE if not found.
 */
function geoserver_layer_type_load($name, $reset = FALSE) {
  ctools_include('plugins');
  $layer_type_class = ctools_plugin_load_class('geoserver', 'layer_types', $name, 'layer_type');

  if ($layer_type_class) {
    $layer_type = new $layer_type_class();
    return $layer_type;
  }
  return FALSE;
}

/**
 * Get path of file where GeoServer's session cookies are stored.
 *
 * @return string Path of GeoServer's session cookie.
 */
function geoserver_get_cookiefile($uid = NULL) {
  if (empty($uid)) {
    global $user;
    $uid = $user->uid;
  }
  return file_directory_temp() . '/geoserver_session_user_' . $uid;
}

/**
 * Parse cookie file.
 *
 * @return array Indexed array of cookies.
 */
function geoserver_parse_cookiefile($file) {
  // Parse cookie file.
  $cookies = array();
  $lines = file($file);
  foreach ($lines as $line) {
    if ('#' === $line{0}) {
      continue;
    }
    $columns = explode("\t", $line);
    if (isset($columns[5]) && isset($columns[6])) {
      $cookies[$columns[5]] = drupal_substr($columns[6], 0, -1);
    }
  }
  return $cookies;
}

function geoserver_styles_load($reset = false) {
  ctools_include('export');

  if ($reset) {
    ctools_export_load_object_reset('geoserver_styles');
  }

  return ctools_export_load_object('geoserver_styles', 'all', array());
}

/**
 * Menu loader for layers. (%geoserver_layer)
 * @ingroup geoserver_api
 *
 * @param $name
 *   Layer name
 * @return array
 *   Layer export
 */
function geoserver_style_load($name, $reset = FALSE) {

  ctools_include('export');

  if ($reset) {
    ctools_export_load_object_reset('geoserver_layers');
  }
  $layers = ctools_export_load_object('geoserver_layers', 'names', array($name));

  if (isset($layers[$name])) {
    return $layers[$name];
  }
  else {
    watchdog('geoserver', 'Layer %layer not found.', array('%layer' => $name), WATCHDOG_ERROR);
    return FALSE;
  }
}

class geoserver_resource_exception extends Exception {};

abstract class geoserver_resource {

  /**
   * Constructor.
   */
  function __construct($local_layer) {
    $this->workspace = variable_get('geoserver_workspace', '');
    $this->local_layer = $local_layer;
  }

  /**
   * Create remote resource.
   */
  abstract function create();

  /**
   * Update remote resource.
   */
  abstract function update();

  /**
   * Delete remote resource.
   */
  abstract function delete();

  /**
   * Read remote resource.
   */
  abstract function read();
}

/**
 * We define base classes in the core module.
 * All other parent classes can be autoloaded through ctools.
 */
abstract class geoserver_layer_type {

  const STATUS_FOUND_SAME = 1;
  const STATUS_FOUND_DIFF = 2;
  const STATUS_NOT_FOUND  = 3;

  public $name;

  /**
   * Constructor.
   */
  function __construct($layer = array()) {

    $this->workspace = variable_get('geoserver_workspace', '');

    foreach (array('name', 'title', 'description', 'data', 'export_type') as $k) {
      if (isset($layer->{$k})) {
        $this->{$k} = $layer->{$k};
      }
    }
  }

  /**
   * Export layer to remote resource definition.
   */
  abstract function to_resource();

  /**
   * Import layer from remote resource definition.
   */
  abstract function from_resource();

  /**
   * Return fields of layer settings form.
   */
  function options_form($defaults = array()) {
    return array();
  }

  /**
   * Get status of layer.
   */
  function get_status() {
    $resource = clone $this;
    $resource->from_resource();
    $layer = $this->to_record();
    $remote = $resource->to_record();
    $layer['data']['options']['sld'] = $remote['data']['options']['sld'];
    if (!empty($resource->name)) {
      if ($layer != $resource->to_record()) {
        return geoserver_layer_type::STATUS_FOUND_DIFF;
      }
      else {
        return geoserver_layer_type::STATUS_FOUND_SAME;
      }
    }
    else {
      return geoserver_layer_type::STATUS_NOT_FOUND;
    }
  }

  /**
   * @return
   *   A version of this layer_type which can be saved,
   *   when attempting to save a modified layer.
   */
  function to_record() {
    return array(
      'name' => $this->name,
      'description' => $this->description,
      'title' => $this->title,
      'data' => $this->data,
    );
  }

  /**
   * @return
   *   Success value on saving this layer
   */
  function save() {
    if (!empty($this->name)) {
      return (db_select('geoserver_layers')
          ->fields('geoserver_layers', array('name'))
          ->condition('name', $this->name)
          ->execute()
          ->fetchCol()) ?
        drupal_write_record('geoserver_layers', $this->to_record(), 'name') :
        drupal_write_record('geoserver_layers', $this->to_record());
    }
  }
}

class geoserver_resource_feature_type extends geoserver_resource {

  public $feature_type;
  public $layer;
  public $sld;

  /**
   * Create remote feature type.
   */
  public function create() {

    $url = 'rest/workspaces/' . $this->workspace . '/datastores/' . $this->local_layer->datastore . '/featuretypes';
    $result = geoserver_post($url . '.json', $this->feature_type);
    if ($result->code != 201) {
      throw new geoserver_resource_exception("Could not create featuretype: $result->data");
    }

    $result = geoserver_put('rest/layers/' . $this->name . '.json', $this->layer);
    if ($result->code != 200) {
      throw new geoserver_resource_exception("Could not update layer: $result->data");
    }
  }

  /**
   * Update remote feature type.
   */
  public function update() {

    $url = 'rest/workspaces/' . $this->workspace . '/datastores/' . $this->local_layer->datastore . '/featuretypes';
    $result = geoserver_put($url . '/' . $this->name . '.json', $this->feature_type);
    if ($result->code != 200) {
      throw new geoserver_resource_exception("Could not update featuretypes: $result->data");
    }

    $result = geoserver_put('rest/layers/' . $this->name . '.json', $this->layer);
    if ($result->code != 200) {
      throw new geoserver_resource_exception("Could not update layer: $result->data");
    }
  }

  /**
   * Delete remote feature type.
   */
  public function delete() {
    $url = 'rest/workspaces/' . $this->workspace . '/datastores/' . $this->local_layer->datastore . '/featuretypes';
    $result = geoserver_delete($url . '/' . $this->local_layer->name . '?recurse=true');
    if ($result->code != 200) {
      throw new geoserver_resource_exception("Could not delete featuretype: $result->data");
    }
  }

  /**
   * Read remote feature type.
   */
  public function read() {

    $url = 'rest/workspaces/' . $this->workspace . '/datastores/' . $this->local_layer->datastore . '/featuretypes/';
    $result = geoserver_get($url . $this->local_layer->name . '.json');
    if ($result->code == 200) {
      $this->feature_type = $result->data;
      $this->layer = NULL;
      $result = geoserver_get('rest/styles/' . $this->local_layer->name . '.sld');
      if ($result->code == 200) {
        $this->sld = $result->data;
      }
    }
    else {
      // TODO: throw exception?
    }
  }
}

/**
 * Vector based layer.
 */
abstract class geoserver_layer_type_feature_type extends geoserver_layer_type {

  /**
   * Export to remote feature type definition.
   */
  abstract function to_feature_type();

  /**
   * Import from remote feature type definition.
   */
  abstract function from_feature_type($feature_type);

  /**
   * Export to remote layer definition.
   */
  function to_layer() {
    return array(
      'layer' => array(
        'name' => $this->name,
        'type' => 'VECTOR',
        'defaultStyle' => array(
          'name' => $this->name,
        ),
        'resource' => array(
          '@class' => 'featureType',
          'name' => $this->name,
        ),
        'enabled' => TRUE,
      ),
    );
  }

  /**
   * Import from remote layer definition.
   */
  function from_layer($layer) {
    // Nothing to do here...
  }

  /**
   * Export layer to remote resource definition.
   */
  function to_resource() {
    $remote_layer = new geoserver_resource_feature_type($this);
    $remote_layer->feature_type = $this->to_feature_type();
    $remote_layer->name = $this->name;
    $remote_layer->layer = $this->to_layer();
    $remote_layer->sld = $this->data['options']['sld'];
    return $remote_layer;
  }

  /**
   * Import layer from remote resource definition.
   */
  function from_resource() {
    $remote_layer = new geoserver_resource_feature_type($this);
    $remote_layer->read();
    $this->from_feature_type($remote_layer->feature_type);
    $this->from_layer($remote_layer->layer);
    $this->data['options']['sld'] = $remote_layer->sld;
  }

}

/**
 * Raster based layer.
 */
abstract class geoserver_layer_type_coverage extends geoserver_layer_type {

  /**
   * Export layer to remote coverage definition.
   */
  abstract function to_coverage();

  /**
   * Import layer from remote coverage definition.
   */
  abstract function from_coverage($coverage);

  /**
   * Create remote layer.
   */
  public function create_remote() {
  }

  /**
   * Update remote layer.
   */
  public function update_remote() {
  }

  /**
   * Delete remote layer.
   */
  public function delete_remote() {
  }

  /**
   * Read remote layer.
   */
  public function read_remote() {
  }
}
